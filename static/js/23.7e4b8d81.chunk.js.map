{"version":3,"sources":["../../../node_modules/topojson-client/src/identity.js","../../../node_modules/topojson-client/src/transform.js","../../../node_modules/topojson-client/src/feature.js","../../../node_modules/topojson-client/src/reverse.js","../../../node_modules/topojson-client/src/bisect.js","../../../node_modules/topojson-server/src/hash/point-hash.js","../../../node_modules/topojson-simplify/src/spherical.js"],"names":["x","transform","identity","x0","y0","kx","scale","ky","dx","translate","dy","input","i","j","n","length","output","Array","topology","o","type","features","geometries","map","feature","id","bbox","properties","geometry","object","transformPoint","arcs","arc","points","pop","a","k","push","array","t","reverse","point","p","line","ring","polygon","coordinates","buffer","ArrayBuffer","Float64Array","Uint32Array","Math","PI","abs","atan2","cos","sin"],"mappings":"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","file":"static/js/23.7e4b8d81.chunk.js","sourcesContent":["export default function(x) {\n  return x;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n","// TODO if quantized, use simpler Int32 hashing?\n\nvar buffer = new ArrayBuffer(16),\n    floats = new Float64Array(buffer),\n    uints = new Uint32Array(buffer);\n\nexport default function(point) {\n  floats[0] = point[0];\n  floats[1] = point[1];\n  var hash = uints[0] ^ uints[1];\n  hash = hash << 5 ^ hash >> 7 ^ uints[2] ^ uints[3];\n  return hash & 0x7fffffff;\n}\n","var pi = Math.PI,\n    tau = 2 * pi,\n    quarterPi = pi / 4,\n    radians = pi / 180,\n    abs = Math.abs,\n    atan2 = Math.atan2,\n    cos = Math.cos,\n    sin = Math.sin;\n\nfunction halfArea(ring, closed) {\n  var i = 0,\n      n = ring.length,\n      sum = 0,\n      point = ring[closed ? i++ : n - 1],\n      lambda0, lambda1 = point[0] * radians,\n      phi1 = (point[1] * radians) / 2 + quarterPi,\n      cosPhi0, cosPhi1 = cos(phi1),\n      sinPhi0, sinPhi1 = sin(phi1);\n\n  for (; i < n; ++i) {\n    point = ring[i];\n    lambda0 = lambda1, lambda1 = point[0] * radians;\n    phi1 = (point[1] * radians) / 2 + quarterPi;\n    cosPhi0 = cosPhi1, cosPhi1 = cos(phi1);\n    sinPhi0 = sinPhi1, sinPhi1 = sin(phi1);\n\n    // Spherical excess E for a spherical triangle with vertices: south pole,\n    // previous point, current point.  Uses a formula derived from Cagnoliâ€™s\n    // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n    // See https://github.com/d3/d3-geo/blob/master/README.md#geoArea\n    var dLambda = lambda1 - lambda0,\n        sdLambda = dLambda >= 0 ? 1 : -1,\n        adLambda = sdLambda * dLambda,\n        k = sinPhi0 * sinPhi1,\n        u = cosPhi0 * cosPhi1 + k * cos(adLambda),\n        v = k * sdLambda * sin(adLambda);\n    sum += atan2(v, u);\n  }\n\n  return sum;\n}\n\nexport function sphericalRingArea(ring, interior) {\n  var sum = halfArea(ring, true);\n  if (interior) sum *= -1;\n  return (sum < 0 ? tau + sum : sum) * 2;\n}\n\nexport function sphericalTriangleArea(t) {\n  return abs(halfArea(t, false)) * 2;\n}\n"],"sourceRoot":""}